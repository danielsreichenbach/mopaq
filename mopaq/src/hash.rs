//! Hash algorithms for MPQ file name hashing

use crate::crypto::ENCRYPTION_TABLE;

/// Hash types for MPQ operations
pub mod hash_type {
    pub const TABLE_OFFSET: u32 = 0;
    pub const NAME_A: u32 = 1;
    pub const NAME_B: u32 = 2;
    pub const FILE_KEY: u32 = 3;
    pub const KEY2_MIX: u32 = 4;
}

/// ASCII uppercase conversion table
pub const ASCII_TO_UPPER: [u8; 256] = [
    // 0x00-0x0F
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    // 0x10-0x1F
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    // 0x20-0x2F
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
    // 0x30-0x3F
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
    // 0x40-0x4F
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
    // 0x50-0x5F
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
    // 0x60-0x6F: a-o -> A-O
    0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
    // 0x70-0x7F: p-z -> P-Z
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
    // 0x80-0x8F
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
    // 0x90-0x9F
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
    // 0xA0-0xAF
    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
    // 0xB0-0xBF
    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
    // 0xC0-0xCF
    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
    // 0xD0-0xDF
    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
    // 0xE0-0xEF
    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
    // 0xF0-0xFF
    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
];

/// ASCII lowercase conversion table
pub const ASCII_TO_LOWER: [u8; 256] = [
    // 0x00-0x0F
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    // 0x10-0x1F
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    // 0x20-0x2F
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
    // 0x30-0x3F
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
    // 0x40-0x4F: @, A-O -> @, a-o
    0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
    // 0x50-0x5F: P-Z -> p-z
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
    // 0x60-0x6F
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
    // 0x70-0x7F
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
    // 0x80-0x8F
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
    // 0x90-0x9F
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
    // 0xA0-0xAF
    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
    // 0xB0-0xBF
    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
    // 0xC0-0xCF
    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
    // 0xD0-0xDF
    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
    // 0xE0-0xEF
    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
    // 0xF0-0xFF
    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
];

/// Hash a string using the MPQ hash algorithm
pub fn hash_string(filename: &str, hash_type: u32) -> u32 {
    let mut seed1: u32 = 0x7FED7FED;
    let mut seed2: u32 = 0xEEEEEEEE;

    for &byte in filename.as_bytes() {
        // Get the next character and normalize it
        let mut ch = byte;

        // Convert path separators to backslash
        if ch == b'/' {
            ch = b'\\';
        }

        // Convert to uppercase using the table
        ch = ASCII_TO_UPPER[ch as usize];

        // Update the hash
        let table_idx = (hash_type * 0x100 + ch as u32) as usize;
        seed1 = ENCRYPTION_TABLE[table_idx] ^ (seed1.wrapping_add(seed2));
        seed2 = (ch as u32)
            .wrapping_add(seed1)
            .wrapping_add(seed2)
            .wrapping_add(seed2 << 5)
            .wrapping_add(3);
    }

    seed1
}

/// Jenkins hash function for HET tables
pub fn jenkins_hash(filename: &str) -> u64 {
    let mut hash: u64 = 0;

    for &byte in filename.as_bytes() {
        // Get the next character and normalize it
        let mut ch = byte;

        // Convert path separators to backslash
        if ch == b'/' {
            ch = b'\\';
        }

        // Convert to lowercase using the table
        ch = ASCII_TO_LOWER[ch as usize];

        // Jenkins one-at-a-time hash algorithm
        hash = hash.wrapping_add(ch as u64);
        hash = hash.wrapping_add(hash << 10);
        hash ^= hash >> 6;
    }

    hash = hash.wrapping_add(hash << 3);
    hash ^= hash >> 11;
    hash = hash.wrapping_add(hash << 15);

    hash
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ascii_tables() {
        // Test uppercase conversion
        assert_eq!(ASCII_TO_UPPER[b'a' as usize], b'A');
        assert_eq!(ASCII_TO_UPPER[b'z' as usize], b'Z');
        assert_eq!(ASCII_TO_UPPER[b'A' as usize], b'A');
        assert_eq!(ASCII_TO_UPPER[b'0' as usize], b'0');
        assert_eq!(ASCII_TO_UPPER[b' ' as usize], b' ');

        // Test lowercase conversion
        assert_eq!(ASCII_TO_LOWER[b'A' as usize], b'a');
        assert_eq!(ASCII_TO_LOWER[b'Z' as usize], b'z');
        assert_eq!(ASCII_TO_LOWER[b'a' as usize], b'a');
        assert_eq!(ASCII_TO_LOWER[b'0' as usize], b'0');
        assert_eq!(ASCII_TO_LOWER[b' ' as usize], b' ');
    }

    #[test]
    fn test_hash_string_test_vectors() {
        // Test vectors from the MPQ format documentation

        // Test 1: "(listfile)"
        assert_eq!(
            hash_string("(listfile)", hash_type::TABLE_OFFSET),
            0x5F3DE859
        );

        // Test 2: "(hash table)"
        assert_eq!(hash_string("(hash table)", hash_type::FILE_KEY), 0xC3AF3770);

        // Test 3: "(block table)"
        assert_eq!(
            hash_string("(block table)", hash_type::FILE_KEY),
            0xEC83B3A3
        );
    }

    #[test]
    fn test_path_separator_normalization() {
        // Both paths should produce the same hash
        let hash1 = hash_string("path/to/file.txt", hash_type::TABLE_OFFSET);
        let hash2 = hash_string("path\\to\\file.txt", hash_type::TABLE_OFFSET);
        assert_eq!(hash1, hash2);

        // Test from documentation
        assert_eq!(
            hash_string("path\\to\\file", hash_type::TABLE_OFFSET),
            hash_string("path/to/file", hash_type::TABLE_OFFSET)
        );
        assert_eq!(
            hash_string("path\\to\\file", hash_type::TABLE_OFFSET),
            0x534CC8EE
        );

        // Test interface path
        assert_eq!(
            hash_string("interface\\glue\\mainmenu.blp", hash_type::TABLE_OFFSET),
            hash_string("interface/glue/mainmenu.blp", hash_type::TABLE_OFFSET)
        );
        assert_eq!(
            hash_string("interface\\glue\\mainmenu.blp", hash_type::TABLE_OFFSET),
            0x2BBE7C09
        );
    }

    #[test]
    fn test_case_insensitivity() {
        // Different cases should produce the same hash
        let hash1 = hash_string("File.txt", hash_type::TABLE_OFFSET);
        let hash2 = hash_string("FILE.TXT", hash_type::TABLE_OFFSET);
        assert_eq!(hash1, hash2);

        // Test from documentation
        assert_eq!(
            hash_string("file.txt", hash_type::TABLE_OFFSET),
            hash_string("FILE.TXT", hash_type::TABLE_OFFSET)
        );
        assert_eq!(hash_string("file.txt", hash_type::TABLE_OFFSET), 0x3EA98D7A);

        assert_eq!(
            hash_string("path\\to\\FILE", hash_type::TABLE_OFFSET),
            hash_string("PATH\\TO\\file", hash_type::TABLE_OFFSET)
        );
        assert_eq!(
            hash_string("path\\to\\FILE", hash_type::TABLE_OFFSET),
            0x534CC8EE
        );
    }

    #[test]
    fn test_jenkins_hash() {
        // Test Jenkins hash for HET tables
        // This test value is derived from the expected behavior
        let hash = jenkins_hash("unit\\neutral\\chicken.mdx");
        // Jenkins hash will be different from the MPQ hash
        assert_ne!(hash, 0); // Basic sanity check

        // Test case insensitivity
        let hash1 = jenkins_hash("File.txt");
        let hash2 = jenkins_hash("FILE.TXT");
        assert_ne!(hash1, hash2); // Jenkins uses lowercase, so these will differ

        // Test path normalization
        let hash1 = jenkins_hash("path/to/file");
        let hash2 = jenkins_hash("path\\to\\file");
        assert_eq!(hash1, hash2);
    }

    #[test]
    fn test_hash_table_lookup_process() {
        // Example of how hash values are used in practice
        let filename = "(listfile)";

        // Calculate the three hash values needed for file lookup
        let hash_a = hash_string(filename, hash_type::NAME_A);
        let hash_b = hash_string(filename, hash_type::NAME_B);
        let hash_offset = hash_string(filename, hash_type::TABLE_OFFSET);

        // Example with hash table size of 0x1000 (4096)
        let hash_table_size = 0x1000u32;
        let index = hash_offset & (hash_table_size - 1);

        // Print for debugging
        println!("Hash A: 0x{:08X}", hash_a);
        println!("Hash B: 0x{:08X}", hash_b);
        println!("Hash offset: 0x{:08X}", hash_offset);
        println!("Table index: 0x{:04X}", index);

        // Verify we get consistent hash values
        assert_eq!(hash_offset, 0xFD5F6EEA);
        // The index should be the lower bits of the hash offset
        assert_eq!(index, 0x6EEA); // 0xFD5F6EEA & 0xFFF = 0x6EEA

        // These hash values are used to find the file in the hash table
        assert_ne!(hash_a, 0); // Just verify they're non-zero
        assert_ne!(hash_b, 0);
    }

    #[test]
    fn test_encryption_key_calculation() {
        // Test file key calculation for encryption
        let filename = "(hash table)";
        let key = hash_string(filename, hash_type::FILE_KEY);

        // This key would be used to decrypt the hash table
        assert_eq!(key, 0xC3AF3770);

        // Test block table key
        let filename = "(block table)";
        let key = hash_string(filename, hash_type::FILE_KEY);
        assert_eq!(key, 0xEC83B3A3);
    }
}
